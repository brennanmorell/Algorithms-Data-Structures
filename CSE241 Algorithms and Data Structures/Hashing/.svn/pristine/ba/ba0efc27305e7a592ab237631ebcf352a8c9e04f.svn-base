//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    
    //
    // Create an empty table big enough to hold maxSize records.
    //
	private Record[] table;
    public StringTable(int maxSize) 
    {
    	table = new Record[maxSize];
    }
    
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	System.out.println("Table Length: " + table.length);
    	System.out.println("Insert: " + r.key);
    	int[] slotsTried = new int[table.length];
    	int k = toHashKey(r.key); ///fix me and make it based off of r
    	int slot = baseHash(k);
    	if(table[slot] == null)
    	{
    		r.positions.add(0, slot);
    		table[slot] = r;
    		System.out.println("Insert: " + r.key + "success @ slot: " + slot);
    		return true;
    	}
    	else
    	{
    		slotsTried[0] = slot;
    		int i = 1;
    		while(i < table.length)
    		{
    			slot = (slotsTried[i-1] + stepHash(k))%table.length;
    			if(table[slot] == null || table[slot].key.equals("deleted")) //if its empty or is where it used to be
    			{
    				r.positions.add(0,slot);
    				table[slot] = r;
    				System.out.println("Insert: " + r.key + "success @ slot: " + slot);
    				return true;
    			}
    			else
    			{
    				if(table[slot].key.equals(r.key))
    				{
    					System.out.println("Insert: " + r.key + "failure @ slot: " + slot);
    					return false;
    				}
    				slotsTried[i] = slot;
    				i++;
    			}
    		}
    	}
    	
    	System.out.println("Insert: " + r.key + "failure @ slot: " + " table full");
    	return false;
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	Record matching = find(r.key);
    	if(matching != null)
    	{
    		System.out.println("Remove: " + r.key + " success @ slot: " + matching.positions.get(0));
    		table[matching.positions.get(0)] = new Record("deleted"); //removed
    		return;
    	}
    	System.out.println("Remove: " + r.key + "not found in table");
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int[] slotsTried = new int[table.length];
    	int k = toHashKey(key); ///fix me and make it based off of r
    	int slot = baseHash(k);
    	if(table[slot] != null)
    	{
    		if(table[slot].key.equals(key))
    		{
    			System.out.println("Find: " + key + " success @ slot: " + slot);
    			return table[slot];
    		}
    		else
    		{
    			
    			slotsTried[0] = slot;
        		int i = 1;
        		while(i < table.length)
        		{
        			slot = (slotsTried[i-1] + stepHash(k))%table.length;
        			if(table[slot] != null)
        			{
        				if(table[slot].key.equals(key))
        				{
        					//we found it! update positions and return it
        					System.out.println("Find: " + key + " success @ slot: " + slot);
        					return table[slot];
        				}
        				else
        				{
        					slotsTried[i] = slot;
        					i++;
        				}
        			}
        			else
        			{
        				//we got to a null it isnt in table
        				System.out.println("Find: " + key + " failure found null @ slot: " + slot);
        				return null;
        			}
        		}
    		}
    	}
    	
    	System.out.println("Find: " + key + " failure @ slot: " + "not in table");
    	return null; //we got to a null so it isnt in table
    	
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
	// Fill in your own hash function here
    	double A = Math.sqrt(2)/2;
    	return ((int)Math.floor(table.length*((hashKey*A)-Math.floor(hashKey*A))))%table.length;
    }
    
    int stepHash(int hashKey)
    {
    	double A = Math.sqrt(5)/22;
    	return ((int)Math.floor(table.length*((hashKey*A)-Math.floor(hashKey*A))))%table.length;
    }
}
